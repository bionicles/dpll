// # DPLL.js
//
// An implementation of the Davis-Putnam-Logemann-Loveland ([DPLL](http://en.wikipedia.org/wiki/DPLL_algorithm))
// algorithm
// for solving the [CNF-SAT](http://en.wikipedia.org/wiki/Boolean_satisfiability_problem) problem that runs on
// [Node.js](http://nodejs.org).
//
// This algorithm decides the satisfiability of propositional logic formulae in conjunctive normal form
// ([CNF](http://en.wikipedia.org/wiki/Conjunctive_normal_form)) - i.e. an *AND* of *OR*s.
//
// The [DPPL.js source](https://github.com/ofmooseandmen/DPLL.js) is available on GitHub, and is released under the MIT
// license.
//
// Most of this documentation actually comes from [wikipedia](http://en.wikipedia.org) and is generated by
// [docco](http://jashkenas.github.io/docco/)
//
// ## Disclaimer
// This implementation is most definitively not as efficient/complete/advanced/... (fill in the blanks!) as those
// entering the [SAT competition](http://www.satcompetition.org/).
//
// ## Why JavaScript?
// [Atwood's Law](http://www.codinghorror.com/blog/2007/07/the-principle-of-least-power.html)!
// > Any application that can be written in JavaScript, will eventually be written in JavaScript.
//
// ## Tests
// This library comes with its unit tests written with [mocha](http://visionmedia.github.io/mocha). To run them simply
// head to the `test`
// directory and execute `mocha *Test.js`
//
// ## Usage
// Let's say you want to solve the following formula:
//
// *(a &or; b) &and; (&not;b &or; c &or; &not;d) &and; (d &or; &not;e)*
//
// In other words you want to know the values of `a`, `b`, `c`, `d` and `e` that make this formula `true`. Here's how you
// do it with **DPLL.js**:
//
//     var dpll = require('*PATH_TO_DPLL.js*/dpll');
//     // create a new CNF formula
//     var formula = new dpll.CnfFormula();
//     var a = {};
//     var b = {};
//     var c = {};
//     var d = {};
//     var e = {};
//     // build the formula
//     formula.openClause(a).or(b).close()
//            .openClauseNot(b).or(c).orNot(d).close()
//            .openClause(d).orNot(e).close();
//
//     // create a new solver for this formula
//     var solver = new dpll.Solver(formula);
//
//     // Et voila!
//     var solution = solver.solve();
//     console.log(solution.get(a));
//
// if the CNF formula has been solved the result will **NOT** contain the variables that have
// been optimized away. For instance if the formula contains the clause ` (x | -x | y) ` and `x` is not
// present in any other clause of the formula, then `x` is optimized away and therefore its value is
// irrelevant - i.e. it could be `true` or `false`.
//
// Two modes for selecting variables in order to apply the *splitting rule* are available.
//
// - random selection amongst unassigned variables; enabled by default or by calling `Solver#randomVariableSelection`
//
// - variable with highest occurrence amongst the unassigned variables; enabled by calling
// `Solver#highestOccurrenceVariableSelection`
//
// The following code snippet enables selection of unassigned variable with highest occurrence:
//
//     var dpll = require('./src/dpll.js');
//     [...]
//     var solver = new dpll.Solver(formula);
//     var solution = solver.highestOccurrenceVariableSelection().solve();
//
// ## More about...
//
// - the DPLL algorithm itself: [Solver.js](./Solver.html)
//
// - the CNF Formula: [CnfFormula.js](./CnfFormula.html)
//
// ## Public API
//
(function() {
    // make `CnfFormula` available
    exports.CnfFormula = require('./CnfFormula');

    // make `Solver` available
    exports.Solver = require('./Solver');
})();
